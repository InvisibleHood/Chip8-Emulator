void emulate_instruction(chip8_t* chip8, config_t config) {
    //Get next opcode from RAM
    chip8->inst.opcode = (chip8->ram[chip8->PC] << 8) | (chip8->ram[chip8->PC + 1]);
    chip8->PC += 2;

    //Fill out current instruction format
    chip8->inst.NNN = chip8->inst.opcode & 0x0FFF;
    chip8->inst.NN = chip8->inst.opcode & 0x0FF;
    chip8->inst.N = chip8->inst.opcode & 0x0F;
    chip8->inst.X = (chip8->inst.opcode >> 8) & 0x0F;
    chip8->inst.Y = (chip8->inst.opcode >> 4) & 0x0F;

#ifdef DEBUG
    print_debug_info(chip8);
#endif

    switch ((chip8->inst.opcode >> 12) & 0x0F) {
        case 0x00:
            if (chip8->inst.NN == 0xE0) {
                //0x00E0: Clear the screen 
                memset(&chip8->display[0], false, sizeof chip8->display);
            } else if (chip8->inst.NN == 0xEE) {
                //0x00EE: Return from subroutine 
                //Set program counter to last address on subroutine stack ("pop" it off the stack)
                chip8->PC = *--chip8->stack_ptr;  //pre-decrement to the previous instruction (jumps back to the previous instruction)
            } else {
                printf("Umimplemented/Invalid Opcode, may be 0xNNN for calling machine code routine for RCA1802.\n");
            }
            break;

        case 0x01:
            //0x1NNN: Jumps to address NNN
            chip8->PC = chip8->inst.NNN; // Set the program counter so that the next opcode is from NNN
            break;

        case 0x02:
            //0x2NNN: Call subroutine at NNN   (like jump register in MIPS: jumps to next instructions)
            //Store current address to return to on subroutine stack 
            //  and set program counter to subroutine address so that 
            //  the next opcode is gotten from there
            *chip8->stack_ptr++ = chip8->PC;   //post increment, the current stack_ptr will store the current instruction and then move on to the next slot on the stack
            chip8->PC = chip8->inst.NNN;   //jumps to the next instruction
            break;

        case 0x03:
            // 0x3XNN: Check if VX == NN, if so, skip the next instruction
            if (chip8->V[chip8->inst.X] == chip8->inst.NN) {
                chip8->PC += 2;
            }
            break;

        case 0x04:
            // 0x4XNN: Check if VX != NN, if so, skip the next instruction
            if (chip8->V[chip8->inst.X] != chip8->inst.NN) {
                chip8->PC += 2;
            }
            break;
            
        case 0x05:
            // 0x5XNN: Check if VX != NN, if so, skip the next instruction
            if (chip8->inst.N != 0) break; // Wrong opcode

            if (chip8->V[chip8->inst.X] == chip8->V[chip8->inst.Y]) {
                chip8->PC += 2;
            }
            break;

        case 0x06:
            //0x6XNN: Set register VX to NN.
            chip8->V[chip8->inst.X] = chip8->inst.NN;
            break;

        case 0x07:
            //0x7XNN: Set register VX += NN.
            chip8->V[chip8->inst.X] += chip8->inst.NN;
            break;

        case 0x08:
            //0x8XNN: 
            if (chip8->inst.N == 0) {
                // 0x8XY0 Sets VX to the value of VY.
                chip8->V[chip8->inst.X] = chip8->V[chip8->inst.Y];
            } else if (chip8->inst.N == 1) {
                // 0x8XY1 Sets VX to VX or VY. (bitwise OR operation)
                chip8->V[chip8->inst.X] |= chip8->V[chip8->inst.Y];
            } else if (chip8->inst.N == 2) {
                // 0x8XY2 Sets VX to VX and VY. (bitwise AND operation)
                chip8->V[chip8->inst.X] &= chip8->V[chip8->inst.Y];
            } else if (chip8->inst.N == 3) {
                // 0x8XY3 Sets VX to VX xor VY
                chip8->V[chip8->inst.X] ^= chip8->V[chip8->inst.Y];
            } else if (chip8->inst.N == 4) {
                // 0x8XY4 Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not
                u_int8_t orig_X = chip8->V[chip8->inst.X];
                chip8->V[chip8->inst.X] += chip8->V[chip8->inst.Y];
                if (orig_X > chip8->V[chip8->inst.X]) { //overflow
                    chip8->V[0xF] = 1;
                } else {
                    chip8->V[0xF] = 0;
                }
            } else if (chip8->inst.N == 5) {
                // 0x8XY5 VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX >= VY and 0 if not)
                if (chip8->V[chip8->inst.X] >= chip8->V[chip8->inst.Y]) {
                    chip8->V[0xF] = 1;
                } else {
                    chip8->V[0xF] = 0;
                }
                chip8->V[chip8->inst.X] -= chip8->V[chip8->inst.Y];
            } else if (chip8->inst.N == 6) {
                // 0x8XY6 Stores the least significant bit of VX in VF and then shifts VX to the right by 1
                chip8->V[0xF] = chip8->V[chip8->inst.X] & 0x01;
                chip8->V[chip8->inst.X] = chip8->V[chip8->inst.X] >> 1;
            } else if (chip8->inst.N == 7) {
                // 0x8XY7 Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX)
                if (chip8->V[chip8->inst.Y] >= chip8->V[chip8->inst.X]) {
                    chip8->V[0xF] = 1;
                } else {
                    chip8->V[0xF] = 0;
                }
                chip8->V[chip8->inst.X] = chip8->V[chip8->inst.Y] - chip8->V[chip8->inst.X];
            } else if (chip8->inst.N == 0xE) {
                // 0x8XYE Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX)
                chip8->V[0xF] = chip8->V[chip8->inst.X] >> 7; 
                chip8->V[chip8->inst.X] = chip8->V[chip8->inst.X] << 1;
            } else {
                printf("Umimplemented/Invalid Opcode for 0x08.\n");
            }
            break;

        case 0x09:
            //0x9XY0: Skips the next instruction if VX does not equal VY. (Usually the next instruction is a jump to skip a code block)
            if (chip8->inst.N != 0) break; // Wrong opcode

            if (chip8->V[chip8->inst.X] != chip8->V[chip8->inst.Y]) {
                chip8->PC += 2;
            }
            break;

        case 0x0A:
            //0xANNN: Set index register I to NNN
            chip8->I = chip8->inst.NNN;
            break;

        case 0x0B:
            //0xBNNN: Jumps to the address NNN plus V0
            chip8->PC = chip8->inst.NNN + chip8->V[0];
            break;

        case 0x0C:
            //0xBNNN: Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.[
            chip8->V[chip8->inst.X] = (rand() % 256) & chip8->inst.NN;
            break;
        
        case 0x0D: { //The reason we need a {} here because all cases share the same scope. It is valid to declare a variable at the start of the block before any executabel statement.   
            //In C, variable declarations must appear before any executable statements within the same block. 
            //  However, this rule applies to inner blocks, such as those within functions, if statements, loops, and switch cases, but not necessarily to the top-level block of a function. At the top level of a function, you can mix declarations and executable statements.
            
            //0xDXYN: Draw N-height sprite at coordinate X, Y. Read from memory location I;
            //  The sprite has a width of 8 pixels and a height of N pixels;
            //  Screen pixels are XOR'd with sprite bits 
            //  VF(Carry Flag) is set if any screen pixels are set off; This is useful 
            //  for collision detection
            uint8_t X_coord = (chip8->V[chip8->inst.X] % config.window_width);
            uint8_t Y_coord = (chip8->V[chip8->inst.Y] % config.window_height);
            const uint8_t orig_X = X_coord;

            chip8->V[0xF] = 0; //Initialize carry flag to 0
            
            //loop over all N rows of the sprite
            for (u_int8_t i = 0; i < chip8->inst.N; i++) {
                //Get next Byte/row of sprite data(The combination of pixels to show the pattern on the screen)
                const u_int8_t sprite_data = chip8->ram[chip8->I + i];
                X_coord = orig_X;

                for (int8_t j = 7; j >= 0; j--) { //The reason we use reversed order is because for each bit in the byte of sprite_data, the most significant bit is the first bit we need to interpret based on the graphical terms
                    //If sprite pixel/bit is on and display pixel is on, set carry flag 
                    bool* pixel = &chip8->display[Y_coord * config.window_width + X_coord];
                    const u_int8_t sprite_bit = (sprite_data & (1 << j)); //why bool does not work?

                    if (sprite_bit && *pixel) {  //both are 1->collision based on XOR 
                        chip8->V[0xF] = 1;
                    }

                    //XOR display pixel with sprite pixel/bit to set it on or off
                    *pixel ^= sprite_bit;

                    //stop drawing if hit the right edge of screen
                    if (++X_coord >= config.window_width) break;
                }

                //Stop drawing entire sprite if hit bottom edge of screen
                if (++Y_coord >= config.window_height) break;
            }
            break;
        }

        case 0x0E:
            if (chip8->inst.NN == 0x9E) {
                //Skips the next instruction if the key stored in VX is pressed
                if (chip8->keypad[chip8->V[chip8->inst.X]]) {
                    chip8->PC += 2;
                }
            } else if (chip8->inst.NN == 0xA1) {
                //Skips the next instruction if the key stored in VX is pressed
                if (!chip8->keypad[chip8->V[chip8->inst.X]]) {
                    chip8->PC += 2;
                }
            } else {
                printf("error code for 0x0E\n");
            }
            break;

        case 0x0F:
            switch (chip8->inst.NN) {
                case 0x0A: {
                    bool any_key_pressed = false;   
                    for (size_t i = 0; i < sizeof chip8->keypad; i++) {
                        if (chip8->keypad[i]) {
                            chip8->V[chip8->inst.X] = i;
                            any_key_pressed = true;
                            break;
                        }
                    }

                    if (!any_key_pressed) {
                        chip8->PC -= 2;
                    }
                    break;
                }
                case 0x1E:
                    chip8->I += chip8->V[chip8->inst.X];
                    break;

                case 0x07:
                    // 0xFX07: VX = delay timer
                    chip8->V[chip8->inst.X] = chip8->delay_timer;
                    break;

                case 0x15:
                    // 0xFX15: delay timer = VX
                    chip8->delay_timer = chip8->V[chip8->inst.X];
                    break;

                case 0x18:
                    // 0xFX18: VX = sound timer
                    chip8->V[chip8->inst.X] = chip8->sound_timer;
                    break;

                case 0x29:
                    // 0xFX29: Set register I to sprite location in memory for character in VX (0x0-0xF)
                    chip8->I = chip8->V[chip8->inst.X] * 5;
                    break;

                case 0x33: {
                    // 0xFX33: Store BCD representation of VX at memory offset from I;
                    //   I = hundred's place, I+1 = ten's place, I+2 = one's place
                    uint8_t bcd = chip8->V[chip8->inst.X];
                    chip8->ram[chip8->I + 2] = bcd % 10;
                    bcd /= 10;
                    chip8->ram[chip8->I + 1] = bcd % 10;
                    bcd /= 10;
                    chip8->ram[chip8->I] = bcd;
                    break;
                }

                case 0x55:
                    for (size_t i = 0; i <= chip8->inst.X; i++) {
                        chip8->ram[chip8->I + i] = chip8->V[i];
                    }
                    break;

                case 0x65:
                    for (size_t i = 0; i <= chip8->inst.X; i++) {
                        chip8->V[i] = chip8->ram[chip8->I + i];
                    }
                    break;

                default: 
                    break;
            }
            break;

        default:
            printf("Umimplemented Opcode.\n");
            break;
    }
}